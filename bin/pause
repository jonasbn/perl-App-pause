#!perl

# PERICMD_INLINE_SCRIPT: {"summary":"A CLI for PAUSE","read_env":1,"subcommands":{"upload":{"url":"/WWW/PAUSE/Simple/upload_files"},"list-mods":{"url":"/WWW/PAUSE/Simple/list_modules"},"list":{"url":"/WWW/PAUSE/Simple/list_files"},"undelete":{"url":"/WWW/PAUSE/Simple/undelete_files"},"ls":{"url":"/WWW/PAUSE/Simple/list_files"},"list-dists":{"url":"/WWW/PAUSE/Simple/list_dists"},"delete":{"url":"/WWW/PAUSE/Simple/delete_files"},"cleanup":{"url":"/WWW/PAUSE/Simple/delete_old_releases"},"rm":{"url":"/WWW/PAUSE/Simple/delete_files"},"reindex":{"url":"/WWW/PAUSE/Simple/reindex_files"}},"pack_deps":0,"url":"/WWW/PAUSE/Simple/","env_name":"GEN_CLI_OPT","validate_args":1,"shebang":"#!perl","config_filename":["pause.conf"],"log":1,"read_config":1,"pod":0}

my $_pci_metas = do{my$a={cleanup=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},num_keep=>{cmdline_aliases=>{n=>{}},default=>1,description=>"\n1 means to only keep the newest version, 2 means to keep the newest and the\nsecond newest, and so on.\n\n",schema=>["int",{min=>1,req=>1},{}],summary=>"Number of new versions (including newest) to keep"},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>["common"]},protect_files=>{schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"Protect some files/wildcard patterns from delete/cleanup",tags=>["category:filtering"],"x.name.is_plural"=>1},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>["common"]},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>["common"]},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>["common"]}},description=>"\nDeveloper releases will not be deleted.\n\nTo delete developer releases, you can use `delete_files` (rm), e.g. from the\ncommand line:\n\n    % pause rm 'My-Module-*TRIAL*'; # delete a dist's trial releases\n    % pause rm '*TRIAL*' '*_*'; # delete all files containing TRIAL or underscore\n\n",features=>{dry_run=>1},result=>{},summary=>"Delete older versions of distributions",v=>1.1},delete=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},protect_files=>{schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"Protect some files/wildcard patterns from delete/cleanup",tags=>'fix',"x.name.is_plural"=>1},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},description=>"\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\n",features=>{dry_run=>1},result=>{},summary=>"Delete files",v=>1.1},list=>{args=>{del=>{schema=>["bool",{},{}],summary=>"Only list files which are scheduled for deletion","summary.alt.bool.not"=>"Only list files which are not scheduled for deletion",tags=>["category:filtering"]},detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},files=>{greedy=>1,pos=>0,schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern",tags=>["category:filtering"],"x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},result=>{},summary=>"List files",v=>1.1},"list-dists"=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},newest=>{description=>"\nDev versions will be skipped.\n\n",schema=>["bool",{},{}],summary=>"Only show newest non-dev version"},newest_n=>{description=>"\nDev versions will be skipped.\n\n",schema=>["int",{min=>1,req=>1},{}],summary=>"Only show this number of newest non-dev versions"},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},description=>"\nDistribution names will be extracted from tarball/zip filenames.\n\nUnknown/unparseable filenames will be skipped.\n\n",result=>{},summary=>"List distributions",v=>1.1},"list-mods"=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},modules=>{greedy=>1,pos=>0,schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"Module names/wildcard patterns","summary.alt.plurality.singular"=>"Module name/wildcard pattern",tags=>["category:filtering"],"x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},type=>{schema=>["str",{req=>1},{}],summary=>"Only list modules matching certain type",tags=>["category:filtering"]},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},result=>{},summary=>"List modules (permissions)",v=>1.1},ls=>{args=>{del=>{schema=>["bool",{},{}],summary=>"Only list files which are scheduled for deletion","summary.alt.bool.not"=>"Only list files which are not scheduled for deletion",tags=>'fix'},detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},files=>{greedy=>1,pos=>0,schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern",tags=>'fix',"x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},result=>{},summary=>"List files",v=>1.1},reindex=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},features=>{dry_run=>1},result=>{},summary=>"Force reindexing",v=>1.1},rm=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},protect_files=>{schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"Protect some files/wildcard patterns from delete/cleanup",tags=>'fix',"x.name.is_plural"=>1},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},description=>"\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\n",features=>'fix',result=>{},summary=>"Delete files",v=>1.1},undelete=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},description=>"\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\n",features=>{dry_run=>1},result=>{},summary=>"Undelete files",v=>1.1},upload=>{args=>{delay=>{description=>"\nIf you upload a lot of files (e.g. 7-10 or more) at a time, the PAUSE indexer\ncurrently might choke with SQLite database locking problem and thus fail to\nindex your releases. Giving a delay of say 2-3 minutes (120-180 seconds) between\nfiles will alleviate this problem.\n\n",schema=>["duration",{req=>1},{}],summary=>"Pause a number of seconds between files"},files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},group_delay=>{description=>"\nAs an alternative to the `delay` option, you can also use this option. This will\ngroup the files to be uploaded by versions and prevent files of the same dist\nand different versions to be uploaded too close to one another, as this might\ncause indexing problem too. For example, suppose you're uploading Foo-1.zip\nFoo-2.zip Foo-3.zip Bar-1.zip Baz-1.zip Baz-2.zip. The files will be uploaded in\nthis order:\n\n    upload: Foo-1.zip Bar-1.zip Baz-1.zip\n    group delay\n    upload: Foo-2.zip Baz-2.zip\n    group delay\n    upload: Foo-3.zip\n\nAs with the `delay` option, it is recommended that if you upload several files\nat once, you set this option to 2-3 minutes (120-180 seconds).\n\n",schema=>["duration",{req=>1},{}],summary=>"Pause a number of seconds between groups of files"},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},subdir=>{default=>"",schema=>["str",{req=>1},{}],summary=>"Subdirectory to put the file(s) into"},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},args_rels=>{choose_one=>["delay","group_delay"]},features=>{dry_run=>1},result=>{},summary=>"Upload file(s)",v=>1.1}};$a->{delete}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{delete}{args}{protect_files}{tags}=$a->{cleanup}{args}{protect_files}{tags};$a->{delete}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{delete}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{delete}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{list}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{list}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{list}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{list}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{"list-dists"}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{"list-dists"}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{"list-dists"}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{"list-dists"}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{"list-mods"}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{"list-mods"}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{"list-mods"}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{"list-mods"}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{ls}{args}{del}{tags}=$a->{list}{args}{del}{tags};$a->{ls}{args}{files}{tags}=$a->{list}{args}{files}{tags};$a->{ls}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{ls}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{ls}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{ls}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{reindex}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{reindex}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{reindex}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{reindex}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{rm}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{rm}{args}{protect_files}{tags}=$a->{cleanup}{args}{protect_files}{tags};$a->{rm}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{rm}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{rm}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{rm}{features}=$a->{delete}{features};$a->{undelete}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{undelete}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{undelete}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{undelete}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{upload}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{upload}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{upload}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{upload}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a};

# This script is generated by Perinci::CmdLine::Inline version 0.47 on Fri Jan 13 13:25:58 2017.

# Rinci metadata taken from these modules: WWW::PAUSE::Simple 0.34

# You probably should not manually edit this file.

# DATE
# VERSION
# PODNAME: 

package main;
use 5.010001;
use strict;
#use warnings;

### declare global variables

our $_pci_meta_result_stream = 0;
our $_pci_meta_result_type;
our $_pci_meta_result_type_is_simple;
our $_pci_meta_skip_format = 0;
our $_pci_r = {naked_res=>0,read_config=>1,read_env=>1,subcommand_name=>""};
our %_pci_args;

### declare subroutines

sub _pci_err {
    my $res = shift;
    print STDERR "ERROR $res->[0]: $res->[1]\n";
    exit $res->[0]-300;
}

sub _pci_json {
    state $json = do {
        if    (eval { require JSON::XS; 1 }) { JSON::XS->new->canonical(1)->allow_nonref }
        elsif (eval { require JSON::PP; 1 }) { JSON::PP->new->canonical(1)->allow_nonref }
        else { require JSON::Tiny::Subclassable; JSON::Tiny::Subclassable->new }
    };
    $json;
}

### get arguments (from config file, env, command-line args

{
my %mentioned_args;
require Getopt::Long::EvenLess;
require Getopt::Long::Subcommand;
my $help_msg = "gen-cli\nUsage:\n  gen-cli --help (or -h, -?)\n  gen-cli --subcommands\n  gen-cli --version (or -v)\n  gen-cli [options]\n\nSubcommands:\n  cleanup\n  delete\n  list\n  list-dists\n  list-mods\n  ls\n  reindex\n  rm\n  undelete\n  upload\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --cmd=s                        Select subcommand\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --subcommands                  List available subcommands\n  --version, -v                  Display program's version and exit\n";
my $go_spec1 = {
  'cmd=s' => sub { $_[2]{subcommand} = [$_[1]]; $_pci_r->{subcommand_name} = $_[1]; },
  'config-path=s@' => sub {         $_pci_r->{config_paths} //= [];        push @{ $_pci_r->{config_paths} }, $_[1]; },
  'config-profile=s' => sub {         $_pci_r->{config_profile} = $_[1]; },
  'format=s' => sub { $_pci_r->{format} = $_[1]; },
  'help|h|?' => sub { my $sc_name = $_pci_r->{subcommand_name}; my $first_non_opt_arg; for (@ARGV) { next if /^-/; $first_non_opt_arg = $_; last } if (!length $sc_name && defined $first_non_opt_arg) { $sc_name = $first_non_opt_arg } if (!length $sc_name) { print $help_msg } elsif ($sc_name eq "") { print "gen-cli\nUsage:\n  gen-cli --help (or -h, -?)\n  gen-cli --subcommands\n  gen-cli --version (or -v)\n  gen-cli [options]\n\nSubcommands:\n  cleanup\n  delete\n  list\n  list-dists\n  list-mods\n  ls\n  reindex\n  rm\n  undelete\n  upload\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --cmd=s                        Select subcommand\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --subcommands                  List available subcommands\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "cleanup") { print "gen-cli cleanup - Delete older versions of distributions\n\nUsage:\n  gen-cli cleanup --help (or -h, -?)\n  gen-cli cleanup --version (or -v)\n  gen-cli cleanup [options]\n\nDeveloper releases will not be deleted.\n\nTo delete developer releases, you can use `delete_files` (rm), e.g. from the\ncommand line:\n\n    % pause rm 'My-Module-*TRIAL*'; # delete a dist's trial releases\n    % pause rm '*TRIAL*' '*_*'; # delete all files containing TRIAL or underscore\n\nMain options:\n  --detail, -l      Whether to return detailed records\n  --num-keep=i, -n  Number of new versions (including newest) to keep [1]\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --protect-file=s\@  Protect some files/wildcard patterns from delete/cleanup\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "delete") { print "gen-cli delete - Delete files\n\nUsage:\n  gen-cli delete --help (or -h, -?)\n  gen-cli delete --version (or -v)\n  gen-cli delete [options] <files> ...\n\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --protect-file=s\@  Protect some files/wildcard patterns from delete/cleanup\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "list") { print "gen-cli list - List files\n\nUsage:\n  gen-cli list --help (or -h, -?)\n  gen-cli list --version (or -v)\n  gen-cli list [options] [files] ...\n\nMain options:\n  --detail, -l  Whether to return detailed records\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --del      Only list files which are scheduled for deletion\n  --file=s\@  File name/wildcard pattern (=arg[0-])\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "list-dists") { print "gen-cli list-dists - List distributions\n\nUsage:\n  gen-cli list-dists --help (or -h, -?)\n  gen-cli list-dists --version (or -v)\n  gen-cli list-dists [options]\n\nDistribution names will be extracted from tarball/zip filenames.\n\nUnknown/unparseable filenames will be skipped.\n\nMain options:\n  --detail, -l  Whether to return detailed records\n  --newest      Only show newest non-dev version\n  --newest-n=i  Only show this number of newest non-dev versions\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "list-mods") { print "gen-cli list-mods - List modules (permissions)\n\nUsage:\n  gen-cli list-mods --help (or -h, -?)\n  gen-cli list-mods --version (or -v)\n  gen-cli list-mods [options] [modules] ...\n\nMain options:\n  --detail, -l  Whether to return detailed records\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --module=s\@  Module name/wildcard pattern (=arg[0-])\n  --type=s     Only list modules matching certain type\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "ls") { print "gen-cli ls - List files\n\nUsage:\n  gen-cli ls --help (or -h, -?)\n  gen-cli ls --version (or -v)\n  gen-cli ls [options] [files] ...\n\nMain options:\n  --detail, -l  Whether to return detailed records\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --del      Only list files which are scheduled for deletion\n  --file=s\@  File name/wildcard pattern (=arg[0-])\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "reindex") { print "gen-cli reindex - Force reindexing\n\nUsage:\n  gen-cli reindex --help (or -h, -?)\n  gen-cli reindex --version (or -v)\n  gen-cli reindex [options] <files> ...\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "rm") { print "gen-cli rm - Delete files\n\nUsage:\n  gen-cli rm --help (or -h, -?)\n  gen-cli rm --version (or -v)\n  gen-cli rm [options] <files> ...\n\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --protect-file=s\@  Protect some files/wildcard patterns from delete/cleanup\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "undelete") { print "gen-cli undelete - Undelete files\n\nUsage:\n  gen-cli undelete --help (or -h, -?)\n  gen-cli undelete --version (or -v)\n  gen-cli undelete [options] <files> ...\n\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "upload") { print "gen-cli upload - Upload file(s)\n\nUsage:\n  gen-cli upload --help (or -h, -?)\n  gen-cli upload --version (or -v)\n  gen-cli upload [options] <files> ...\n\nMain options:\n  --delay=s        Pause a number of seconds between files\n  --file=s\@*       File name/wildcard pattern (=arg[0-])\n  --group-delay=s  Pause a number of seconds between groups of files\n  --subdir=s       Subdirectory to put the file(s) into [\"\"]\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --help, -h, -?                 Display help message and exit\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --username=s*                  PAUSE ID\n  --version, -v                  Display program's version and exit\n" } else { _pci_err([500, "Unknown subcommand2: $sc_name"]) } exit 0 },
  'json' => sub { $_pci_r->{format} = (-t STDOUT) ? "json-pretty" : "json"; },
  'naked-res' => sub { $_pci_r->{naked_res} = 1; },
  'no-config' => sub {         $_pci_r->{read_config} = 0; },
  'no-env' => sub {         $_pci_r->{read_env} = 0; },
  'no-naked-res|nonaked-res' => sub { $_pci_r->{naked_res} = 0; },
  'subcommands' => sub { print "Available subcommands:\n  cleanup\n  delete\n  list\n  list-dists\n  list-mods\n  ls\n  reindex\n  rm\n  undelete\n  upload\n"; exit 0 },
  'version|v' => sub { no warnings 'once'; require WWW::PAUSE::Simple; print "gen-cli version ", ($WWW::PAUSE::Simple::VERSION // '?'), ($WWW::PAUSE::Simple::DATE ? " ($WWW::PAUSE::Simple::DATE)" : ''), "\n"; print "  Generated by Perinci::CmdLine::Inline version 0.47 (2017-01-12)\n"; exit 0 },
};
my $go_spec2 = {
  options => {
    'cmd=s' => {
      handler => sub { $_[2]{subcommand} = [$_[1]]; $_pci_r->{subcommand_name} = $_[1]; },
    },
    'config-path=s@' => {
      handler => sub {},
    },
    'config-profile=s' => {
      handler => sub {},
    },
    'format=s' => {
      handler => sub {},
    },
    'help|h|?' => {
      handler => sub {},
    },
    'json' => {
      handler => sub {},
    },
    'naked-res' => {
      handler => sub {},
    },
    'no-config' => {
      handler => sub {},
    },
    'no-env' => {
      handler => sub {},
    },
    'no-naked-res|nonaked-res' => {
      handler => sub {},
    },
    'subcommands' => {
      handler => sub {},
    },
    'version|v' => {
      handler => sub {},
    },
  },
  subcommands => {
    'cleanup' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'n=i' => {
          handler => sub { $_pci_args{'num_keep'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'num-keep=i' => {
          handler => sub { $_pci_args{'num_keep'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'protect-file=s@' => {
          handler => sub { if ($mentioned_args{'protect_files'}++) { push @{ $_pci_args{'protect_files'} }, $_[1] } else { $_pci_args{'protect_files'} = [$_[1]] } },
        },
        'protect-files-json=s' => {
          handler => sub { $_pci_args{'protect_files'} = _pci_json()->decode($_[1]); },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'delete' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'protect-file=s@' => {
          handler => sub { if ($mentioned_args{'protect_files'}++) { push @{ $_pci_args{'protect_files'} }, $_[1] } else { $_pci_args{'protect_files'} = [$_[1]] } },
        },
        'protect-files-json=s' => {
          handler => sub { $_pci_args{'protect_files'} = _pci_json()->decode($_[1]); },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'list' => {
      options => {
        'del' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'no-del' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nodel' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'list-dists' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'newest' => {
          handler => sub { $_pci_args{'newest'} = $_[1]; },
        },
        'newest-n=i' => {
          handler => sub { $_pci_args{'newest_n'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'no-newest' => {
          handler => sub { $_pci_args{'newest'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nonewest' => {
          handler => sub { $_pci_args{'newest'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'list-mods' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'module=s@' => {
          handler => sub { if ($mentioned_args{'modules'}++) { push @{ $_pci_args{'modules'} }, $_[1] } else { $_pci_args{'modules'} = [$_[1]] } },
        },
        'modules-json=s' => {
          handler => sub { $_pci_args{'modules'} = _pci_json()->decode($_[1]); },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'type=s' => {
          handler => sub { $_pci_args{'type'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'ls' => {
      options => {
        'del' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'no-del' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nodel' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'reindex' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'rm' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'protect-file=s@' => {
          handler => sub { if ($mentioned_args{'protect_files'}++) { push @{ $_pci_args{'protect_files'} }, $_[1] } else { $_pci_args{'protect_files'} = [$_[1]] } },
        },
        'protect-files-json=s' => {
          handler => sub { $_pci_args{'protect_files'} = _pci_json()->decode($_[1]); },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'undelete' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'upload' => {
      options => {
        'delay=s' => {
          handler => sub { $_pci_args{'delay'} = $_[1]; },
        },
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'group-delay=s' => {
          handler => sub { $_pci_args{'group_delay'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'subdir=s' => {
          handler => sub { $_pci_args{'subdir'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
  },
  default_subcommand => undef,
};
{
  local @ARGV = @ARGV;
  my $old_conf = Getopt::Long::EvenLess::Configure("pass_through");
  Getopt::Long::EvenLess::GetOptions(%$go_spec1);
  Getopt::Long::EvenLess::Configure($old_conf);
  { my $first_non_opt_arg; for (@ARGV) { next if /^-/; $first_non_opt_arg = $_; last } if (!length $_pci_r->{subcommand_name} && defined $first_non_opt_arg) { $_pci_r->{subcommand_name} = $first_non_opt_arg } }
}
{
  last unless $_pci_r->{read_env};
  my $env = $ENV{"GEN_CLI_OPT"};
  last unless defined $env;
  require Complete::Bash;
  my ($words, undef) = @{ Complete::Bash::parse_cmdline($env, 0) };
  unshift @ARGV, @$words;
}
if ($_pci_r->{read_config}) {
  require Perinci::CmdLine::Util::Config;

  my $res = Perinci::CmdLine::Util::Config::read_config(
    config_paths     => $_pci_r->{config_paths},
    config_filename  => ["pause.conf"],
    config_dirs      => undef // ["$ENV{HOME}/.config", $ENV{HOME}, "/etc"],
    program_name     => "gen-cli",
  );
  _pci_err($res) unless $res->[0] == 200;
  $_pci_r->{config} = $res->[2];
  $_pci_r->{read_config_files} = $res->[3]{"func.read_files"};
  $_pci_r->{_config_section_read_order} = $res->[3]{"func.section_read_order"}; # we currently dont want to publish this request key

  $res = Perinci::CmdLine::Util::Config::get_args_from_config(
    r                  => $_pci_r,
    config             => $_pci_r->{config},
    args               => \%_pci_args,
    program_name       => "gen-cli",
    subcommand_name    => $_pci_r->{subcommand_name},
    config_profile     => $_pci_r->{config_profile},
    common_opts        => {},
    meta               => $_pci_metas->{ $_pci_r->{subcommand_name} },
    meta_is_normalized => 1,
  );
  die $res unless $res->[0] == 200;
  my $found = $res->[3]{"func.found"};
  if (defined($_pci_r->{config_profile}) && !$found && defined($_pci_r->{read_config_files}) && @{$_pci_r->{read_config_files}} && !$_pci_r->{ignore_missing_config_profile_section}) {
    _pci_err([412, "Profile '$_pci_r->{config_profile}' not found in configuration file"]);
  }
}
my $res = Getopt::Long::Subcommand::GetOptions(%$go_spec2);
_pci_err([500, "GetOptions failed"]) unless $res->{success};
if (!length $_pci_r->{subcommand_name}) { print $help_msg; exit 0 }
}

### check arguments

{
my $res = _pci_check_args(\%_pci_args);
_pci_err($res) if $res->[0] != 200;
$_pci_r->{args} = \%_pci_args;
}

### call function

{
my $sc_name = $_pci_r->{subcommand_name};
if ($sc_name eq "cleanup") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::delete_old_releases(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "delete") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::delete_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "list") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "list-dists") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_dists(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "list-mods") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_modules(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "ls") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "reindex") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::reindex_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "rm") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::delete_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "undelete") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::undelete_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "upload") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::upload_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
}

### format & display result

{
my $fres;
my $save_res; if (exists $_pci_r->{res}[3]{"cmdline.result"}) { $save_res = $_pci_r->{res}[2]; $_pci_r->{res}[2] = $_pci_r->{res}[3]{"cmdline.result"} }
my $is_success = $_pci_r->{res}[0] =~ /\A2/ || $_pci_r->{res}[0] == 304;
my $is_stream = $_pci_r->{res}[3]{stream} // $_pci_meta_result_stream // 0;
if ($is_success && (0 || $_pci_meta_skip_format || $_pci_r->{res}[3]{"cmdline.skip_format"})) { $fres = $_pci_r->{res}[2] }
elsif ($is_success && $is_stream) {}
else { require Perinci::Result::Format::Lite; $is_stream=0; _pci_clean_json($_pci_r->{res}); $fres = Perinci::Result::Format::Lite::format($_pci_r->{res}, ($_pci_r->{format} // $_pci_r->{res}[3]{"cmdline.default_format"} // "text"), $_pci_r->{naked_res}, 0) }

my $use_utf8 = $_pci_r->{res}[3]{"x.hint.result_binary"} ? 0 : 0;
if ($use_utf8) { binmode STDOUT, ":utf8" }
if ($is_stream) {
    my $code = $_pci_r->{res}[2]; if (ref($code) ne "CODE") { die "Result is a stream but no coderef provided" } if ($_pci_meta_result_type_is_simple) { while(defined(my $l=$code->())) { print $l; print "\n" unless $_pci_meta_result_type eq "buf"; } } else { while (defined(my $rec=$code->())) { print _pci_json()->encode($rec),"\n" } }
} else {
    print $fres;
}
if (defined $save_res) { $_pci_r->{res}[2] = $save_res }
}

### exit

{
my $status = $_pci_r->{res}[0];
my $exit_code = $_pci_r->{res}[3]{"cmdline.exit_code"} // ($status =~ /200|304/ ? 0 : ($status-300));
exit($exit_code);
}

# BEGIN Local::_pci_check_args
sub _pci_check_args {
    my ($args) = @_;
    my $sc_name = $_pci_r->{subcommand_name};
    if ($sc_name eq "cleanup") {
      FILL_FROM_POS: {
            1;
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"num_keep"} //= 1;
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: num_keep"] if exists($args->{"num_keep"}) && !defined($args->{"num_keep"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: protect_files"] if exists($args->{"protect_files"}) && !defined($args->{"protect_files"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "delete") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: protect_files"] if exists($args->{"protect_files"}) && !defined($args->{"protect_files"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "list") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "list-dists") {
      FILL_FROM_POS: {
            1;
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: newest_n"] if exists($args->{"newest_n"}) && !defined($args->{"newest_n"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "list-mods") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"modules"}) { return [400, "You specified --module but also argument #0"]; } else { $args->{"modules"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: modules"] if exists($args->{"modules"}) && !defined($args->{"modules"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required value for argument: type"] if exists($args->{"type"}) && !defined($args->{"type"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "ls") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "reindex") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "rm") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: protect_files"] if exists($args->{"protect_files"}) && !defined($args->{"protect_files"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "undelete") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "upload") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;
        $args->{"subdir"} //= "";

        # check required args
        return [400, "Missing required value for argument: delay"] if exists($args->{"delay"}) && !defined($args->{"delay"});
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required value for argument: group_delay"] if exists($args->{"group_delay"}) && !defined($args->{"group_delay"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required value for argument: subdir"] if exists($args->{"subdir"}) && !defined($args->{"subdir"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    } else { _pci_err([500, "Unknown subcommand1: $sc_name"]); }
}
1;

# END Local::_pci_check_args

# BEGIN Local::_pci_clean_json
require Scalar::Util; use feature 'state'; sub _pci_clean_json { state $cleanser = sub {
require Scalar::Util;
my $data = shift;
state %refs;
state $ctr_circ;
state $process_array;
state $process_hash;
if (!$process_array) { $process_array = sub { my $a = shift; for my $e (@$a) { my $ref=ref($e);
    if ($ref && $refs{ $e }++) { if (++$ctr_circ <= 1) { $e = Data::Clone::clone($e); redo } else { $e = 'CIRCULAR'; $ref = '' } }
    elsif ($ref eq 'DateTime') { $e = $e->epoch; $ref = ref($e) }
    elsif ($ref eq 'Math::BigInt') { $e = $e->bstr; $ref = ref($e) }
    elsif ($ref eq 'Regexp') { $e = "$e"; $ref = "" }
    elsif ($ref eq 'SCALAR') { $e = ${ $e }; $ref = ref($e) }
    elsif ($ref eq 'Time::Moment') { $e = $e->epoch; $ref = ref($e) }
    elsif ($ref eq 'version') { $e = "$e"; $ref = "" }
    elsif (Scalar::Util::blessed($e)) { if (!$Data::Clean::_clone && 0) { $e = Acme::Damn::damn($e) } else { $e = Function::Fallback::CoreOrPP::_unbless_fallback($e) } $ref = ref($e) }
    my $reftype=Scalar::Util::reftype($e)//"";
    if ($reftype eq "ARRAY") { $process_array->($e) }
    elsif ($reftype eq "HASH") { $process_hash->($e) }
    elsif ($ref) { $e = $ref; $ref = "" }
} } }
if (!$process_hash) { $process_hash = sub { my $h = shift; for my $k (keys %$h) { my $ref=ref($h->{$k});
    if ($ref && $refs{ $h->{$k} }++) { if (++$ctr_circ <= 1) { $h->{$k} = Data::Clone::clone($h->{$k}); redo } else { $h->{$k} = 'CIRCULAR'; $ref = '' } }
    elsif ($ref eq 'DateTime') { $h->{$k} = $h->{$k}->epoch; $ref = ref($h->{$k}) }
    elsif ($ref eq 'Math::BigInt') { $h->{$k} = $h->{$k}->bstr; $ref = ref($h->{$k}) }
    elsif ($ref eq 'Regexp') { $h->{$k} = "$h->{$k}"; $ref = "" }
    elsif ($ref eq 'SCALAR') { $h->{$k} = ${ $h->{$k} }; $ref = ref($h->{$k}) }
    elsif ($ref eq 'Time::Moment') { $h->{$k} = $h->{$k}->epoch; $ref = ref($h->{$k}) }
    elsif ($ref eq 'version') { $h->{$k} = "$h->{$k}"; $ref = "" }
    elsif (Scalar::Util::blessed($h->{$k})) { if (!$Data::Clean::_clone && 0) { $h->{$k} = Acme::Damn::damn($h->{$k}) } else { $h->{$k} = Function::Fallback::CoreOrPP::_unbless_fallback($h->{$k}) } $ref = ref($h->{$k}) }
    my $reftype=Scalar::Util::reftype($h->{$k})//"";
    if ($reftype eq "ARRAY") { $process_array->($h->{$k}) }
    elsif ($reftype eq "HASH") { $process_hash->($h->{$k}) }
    elsif ($ref) { $h->{$k} = $ref; $ref = "" }
} } }
%refs = (); $ctr_circ=0;
for ($data) { my $ref=ref($_);
    if ($ref && $refs{ $_ }++) { if (++$ctr_circ <= 1) { $_ = Data::Clone::clone($_); redo } else { $_ = 'CIRCULAR'; $ref = '' } }
    elsif ($ref eq 'DateTime') { $_ = $_->epoch; $ref = ref($_) }
    elsif ($ref eq 'Math::BigInt') { $_ = $_->bstr; $ref = ref($_) }
    elsif ($ref eq 'Regexp') { $_ = "$_"; $ref = "" }
    elsif ($ref eq 'SCALAR') { $_ = ${ $_ }; $ref = ref($_) }
    elsif ($ref eq 'Time::Moment') { $_ = $_->epoch; $ref = ref($_) }
    elsif ($ref eq 'version') { $_ = "$_"; $ref = "" }
    elsif (Scalar::Util::blessed($_)) { if (!$Data::Clean::_clone && 0) { $_ = Acme::Damn::damn($_) } else { $_ = Function::Fallback::CoreOrPP::_unbless_fallback($_) } $ref = ref($_) }
    my $reftype=Scalar::Util::reftype($_)//"";
    if ($reftype eq "ARRAY") { $process_array->($_) }
    elsif ($reftype eq "HASH") { $process_hash->($_) }
    elsif ($ref) { $_ = $ref; $ref = "" }
}
$data
}
;; $cleanser->(shift) }
1;

# END Local::_pci_clean_json



=head1 SYNOPSIS

First create a config file C<~/pause.conf> containing:

 username=<Your PAUSE ID>
 password=<Your PAUSE password>

or if you have C<~/.pause> from L<cpan-upload>, C<pause> can read it too
(encrypted C<.pause> is currently not supported).

Then:

 # upload one or more files
 % pause upload Foo-Bar-0.12.tar.gz Baz-2.24.tar.gz
 % pause upload Foo-Bar-0.12.tar.gz --subdir old/2014; # upload to a subdir

 # list your files
 % pause list
 % pause ls 'App-*'; # accept filenames/wildcard patterns, note: quote first
 % pause ls -l     ; # see file sizes/mtimes/etc instead of just names

 # list your dists
 % pause list-dists

 # delete files
 % pause delete Foo-Bar-0.12.tar.gz Foo-Bar-0.12.readme Foo-Bar-0.12.meta
 % pause rm 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # undelete files scheduled for deletion (but not actually deleted yet)
 % pause undelete Foo-Bar-0.12.tar.gz Foo-Bar-0.12.readme Foo-Bar-0.12.meta
 % pause undelete 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # force reindexing
 % pause reindex Foo-Bar-0.12.tar.gz Foo-Bar-0.12.meta
 % pause reindex 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # clean old releases, by default will only leave the newest non-dev version
 % pause cleanup
 % pause cleanup -n 3 ; # keep 3 versions (newest + previous two)

To view permissions:

 # list all modules that you have permissions of
 % pause list-mods
 % pause list-mods -l ; # show detail

 # list all modules matching a wildcard
 % pause list-mods -l 'Unix*'

 # list all modules you have co-maint of
 % pause list-mods -l --type co-maint

To change permissions (not yet implemented):

 ...

To change your password (not yet implemented):

 ...

To view your account info (not yet implemented):

 ...

To change your email forwarding (not yet implemented):

 ...


=head1 FILES

F<~/.pause>

=cut
