#!perl

# PERICMD_INLINE_SCRIPT: {"config_filename":["pause.conf"],"env_name":"PAUSE_OPT","log":1,"pack_deps":0,"pod":0,"read_config":1,"read_env":1,"script_name":"pause","script_version_from_main_version":1,"shebang":"#!perl","subcommands":{"cleanup":{"url":"/WWW/PAUSE/Simple/delete_old_releases"},"ls":{"url":"/WWW/PAUSE/Simple/list_files"},"ls-dists":{"url":"/WWW/PAUSE/Simple/list_dists"},"ls-mods":{"url":"/WWW/PAUSE/Simple/list_modules"},"reindex":{"url":"/WWW/PAUSE/Simple/reindex_files"},"rm":{"url":"/WWW/PAUSE/Simple/delete_files"},"undelete":{"url":"/WWW/PAUSE/Simple/undelete_files"},"upload":{"url":"/WWW/PAUSE/Simple/upload_files"}},"summary":"A CLI for PAUSE","url":"/WWW/PAUSE/Simple/","use_cleanser":0,"validate_args":1}

my $_pci_metas = do{my$a={cleanup=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},num_keep=>{cmdline_aliases=>{n=>{}},default=>1,description=>"\n1 means to only keep the newest version, 2 means to keep the newest and the\nsecond newest, and so on.\n\n",schema=>["int",{min=>1,req=>1},{}],summary=>"Number of new versions (including newest) to keep"},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>["common"]},protect_files=>{schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"Protect some files/wildcard patterns from delete/cleanup",tags=>["category:filtering"],"x.name.is_plural"=>1},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>["common"]},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>["common"]},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>["common"]}},description=>"\nDeveloper releases will not be deleted.\n\nTo delete developer releases, you can use `delete_files` (rm), e.g. from the\ncommand line:\n\n    % pause rm 'My-Module-*TRIAL*'; # delete a dist's trial releases\n    % pause rm '*TRIAL*' '*_*'; # delete all files containing TRIAL or underscore\n\n",features=>{dry_run=>1},result=>{},summary=>"Delete older versions of distributions",v=>1.1},ls=>{args=>{del=>{schema=>["bool",{},{}],summary=>"Only list files which are scheduled for deletion","summary.alt.bool.not"=>"Only list files which are not scheduled for deletion",tags=>["category:filtering"]},detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},files=>{greedy=>1,pos=>0,schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern",tags=>["category:filtering"],"x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},result=>{},summary=>"List files",v=>1.1},"ls-dists"=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},newest=>{description=>"\nDev versions will be skipped.\n\n",schema=>["bool",{},{}],summary=>"Only show newest non-dev version"},newest_n=>{description=>"\nDev versions will be skipped.\n\n",schema=>["int",{min=>1,req=>1},{}],summary=>"Only show this number of newest non-dev versions"},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},description=>"\nDistribution names will be extracted from tarball/zip filenames.\n\nUnknown/unparseable filenames will be skipped.\n\n",result=>{},summary=>"List distributions",v=>1.1},"ls-mods"=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{},{}],summary=>"Whether to return detailed records"},modules=>{greedy=>1,pos=>0,schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"Module names/wildcard patterns","summary.alt.plurality.singular"=>"Module name/wildcard pattern",tags=>["category:filtering"],"x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},type=>{schema=>["str",{req=>1},{}],summary=>"Only list modules matching certain type",tags=>["category:filtering"]},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},result=>{},summary=>"List modules (permissions)",v=>1.1},reindex=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},features=>{dry_run=>1},result=>{},summary=>"Force reindexing",v=>1.1},rm=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},protect_files=>{schema=>["array",{of=>["str",{req=>1},{}],req=>1},{}],summary=>"Protect some files/wildcard patterns from delete/cleanup",tags=>'fix',"x.name.is_plural"=>1},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},description=>"\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\n",features=>{dry_run=>1},result=>{},summary=>"Delete files",v=>1.1},undelete=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},description=>"\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\n",features=>{dry_run=>1},result=>{},summary=>"Undelete files",v=>1.1},upload=>{args=>{delay=>{description=>"\nIf you upload a lot of files (e.g. 7-10 or more) at a time, the PAUSE indexer\ncurrently might choke with SQLite database locking problem and thus fail to\nindex your releases. Giving a delay of say 2-3 minutes (120-180 seconds) between\nfiles will alleviate this problem.\n\n",schema=>["duration",{req=>1},{}],summary=>"Pause a number of seconds between files"},files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1},{}],req=>1},{}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,req=>1,schema=>["str",{req=>1},{}],summary=>"PAUSE password",tags=>'fix'},retries=>{default=>2,schema=>["int",{req=>1},{}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'fix'},retry_delay=>{default=>3,schema=>["duration",{req=>1},{}],summary=>"How long to wait before retrying",tags=>'fix'},subdir=>{default=>"",schema=>["str",{req=>1},{}],summary=>"Subdirectory to put the file(s) into"},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",req=>1,schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1},{}],summary=>"PAUSE ID",tags=>'fix'}},args_rels=>{choose_one=>["delay"]},features=>{dry_run=>1},result=>{},summary=>"Upload file(s)",v=>1.1}};$a->{ls}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{ls}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{ls}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{ls}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{"ls-dists"}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{"ls-dists"}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{"ls-dists"}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{"ls-dists"}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{"ls-mods"}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{"ls-mods"}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{"ls-mods"}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{"ls-mods"}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{reindex}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{reindex}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{reindex}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{reindex}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{rm}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{rm}{args}{protect_files}{tags}=$a->{cleanup}{args}{protect_files}{tags};$a->{rm}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{rm}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{rm}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{undelete}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{undelete}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{undelete}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{undelete}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a->{upload}{args}{password}{tags}=$a->{cleanup}{args}{password}{tags};$a->{upload}{args}{retries}{tags}=$a->{cleanup}{args}{retries}{tags};$a->{upload}{args}{retry_delay}{tags}=$a->{cleanup}{args}{retry_delay}{tags};$a->{upload}{args}{username}{tags}=$a->{cleanup}{args}{username}{tags};$a};

# This script is generated by Perinci::CmdLine::Inline version 0.48 on Mon Jan 16 22:37:07 2017.

# Rinci metadata taken from these modules: WWW::PAUSE::Simple 0.35

# You probably should not manually edit this file.

# DATE
# VERSION
# PODNAME: pause

package main;
use 5.010001;
use strict;
#use warnings;

### enable logging
require Log::Any; my $log = Log::Any->get_logger;
require Log::Any::Adapter;
Log::Any::Adapter->set("Screen");

### declare global variables

our $_pci_meta_result_stream = 0;
our $_pci_meta_result_type;
our $_pci_meta_result_type_is_simple;
our $_pci_meta_skip_format = 0;
our $_pci_r = {naked_res=>0,read_config=>1,read_env=>1,subcommand_name=>""};
our %_pci_args;

### declare subroutines

sub _pci_err {
    my $res = shift;
    print STDERR "ERROR $res->[0]: $res->[1]\n";
    exit $res->[0]-300;
}

sub _pci_json {
    state $json = do {
        if (eval { require JSON::XS; 1 }) { JSON::XS->new->canonical(1)->allow_nonref }
        else { require JSON::PP; JSON::PP->new->canonical(1)->allow_nonref }
    };
    $json;
}

### get arguments (from config file, env, command-line args

{
my %mentioned_args;
require Getopt::Long::EvenLess;
$log->tracef("Parsing command-line arguments ...");
require Getopt::Long::Subcommand;
my $help_msg = "pause\nUsage:\n  pause --help (or -h, -?)\n  pause --subcommands\n  pause --version (or -v)\n  pause [options]\n\nSubcommands:\n  cleanup\n  ls\n  ls-dists\n  ls-mods\n  reindex\n  rm\n  undelete\n  upload\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --cmd=s                        Select subcommand\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --quiet                        Set logging level to error\n  --subcommands                  List available subcommands\n  --trace                        Set logging level to trace\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n";
my $go_spec1 = {
  'cmd=s' => sub { $_[2]{subcommand} = [$_[1]]; $_pci_r->{subcommand_name} = $_[1]; },
  'config-path=s@' => sub { $_pci_r->{config_paths} //= []; push @{ $_pci_r->{config_paths} }, $_[1]; },
  'config-profile=s' => sub { $_pci_r->{config_profile} = $_[1]; },
  'debug' => sub { Log::Any::Adapter->set("Screen", min_level=>"debug"); $_pci_r->{log_level} = "debug"; },
  'format=s' => sub { $_pci_r->{format} = $_[1]; },
  'help|h|?' => sub { my $sc_name = $_pci_r->{subcommand_name}; my $first_non_opt_arg; for (@ARGV) { next if /^-/; $first_non_opt_arg = $_; last } if (!length $sc_name && defined $first_non_opt_arg) { $sc_name = $first_non_opt_arg } if (!length $sc_name) { print $help_msg } elsif ($sc_name eq "") { print "pause\nUsage:\n  pause --help (or -h, -?)\n  pause --subcommands\n  pause --version (or -v)\n  pause [options]\n\nSubcommands:\n  cleanup\n  ls\n  ls-dists\n  ls-mods\n  reindex\n  rm\n  undelete\n  upload\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --cmd=s                        Select subcommand\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --quiet                        Set logging level to error\n  --subcommands                  List available subcommands\n  --trace                        Set logging level to trace\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "cleanup") { print "pause cleanup - Delete older versions of distributions\n\nUsage:\n  pause cleanup --help (or -h, -?)\n  pause cleanup --version (or -v)\n  pause cleanup [options]\n\nDeveloper releases will not be deleted.\n\nTo delete developer releases, you can use `delete_files` (rm), e.g. from the\ncommand line:\n\n    % pause rm 'My-Module-*TRIAL*'; # delete a dist's trial releases\n    % pause rm '*TRIAL*' '*_*'; # delete all files containing TRIAL or underscore\n\nMain options:\n  --detail, -l      Whether to return detailed records\n  --num-keep=i, -n  Number of new versions (including newest) to keep [1]\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --protect-file=s\@  Protect some files/wildcard patterns from delete/cleanup\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --quiet                        Set logging level to error\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --trace                        Set logging level to trace\n  --username=s*                  PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "ls") { print "pause ls - List files\n\nUsage:\n  pause ls --help (or -h, -?)\n  pause ls --version (or -v)\n  pause ls [options] [files] ...\n\nMain options:\n  --detail, -l  Whether to return detailed records\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --del      Only list files which are scheduled for deletion\n  --file=s\@  File name/wildcard pattern (=arg[0-])\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --quiet                        Set logging level to error\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --trace                        Set logging level to trace\n  --username=s*                  PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "ls-dists") { print "pause ls-dists - List distributions\n\nUsage:\n  pause ls-dists --help (or -h, -?)\n  pause ls-dists --version (or -v)\n  pause ls-dists [options]\n\nDistribution names will be extracted from tarball/zip filenames.\n\nUnknown/unparseable filenames will be skipped.\n\nMain options:\n  --detail, -l  Whether to return detailed records\n  --newest      Only show newest non-dev version\n  --newest-n=i  Only show this number of newest non-dev versions\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --quiet                        Set logging level to error\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --trace                        Set logging level to trace\n  --username=s*                  PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "ls-mods") { print "pause ls-mods - List modules (permissions)\n\nUsage:\n  pause ls-mods --help (or -h, -?)\n  pause ls-mods --version (or -v)\n  pause ls-mods [options] [modules] ...\n\nMain options:\n  --detail, -l  Whether to return detailed records\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --module=s\@  Module name/wildcard pattern (=arg[0-])\n  --type=s     Only list modules matching certain type\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --quiet                        Set logging level to error\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --trace                        Set logging level to trace\n  --username=s*                  PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "reindex") { print "pause reindex - Force reindexing\n\nUsage:\n  pause reindex --help (or -h, -?)\n  pause reindex --version (or -v)\n  pause reindex [options] <files> ...\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --quiet                        Set logging level to error\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --trace                        Set logging level to trace\n  --username=s*                  PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "rm") { print "pause rm - Delete files\n\nUsage:\n  pause rm --help (or -h, -?)\n  pause rm --version (or -v)\n  pause rm [options] <files> ...\n\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --protect-file=s\@  Protect some files/wildcard patterns from delete/cleanup\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --quiet                        Set logging level to error\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --trace                        Set logging level to trace\n  --username=s*                  PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "undelete") { print "pause undelete - Undelete files\n\nUsage:\n  pause undelete --help (or -h, -?)\n  pause undelete --version (or -v)\n  pause undelete [options] <files> ...\n\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --quiet                        Set logging level to error\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --trace                        Set logging level to trace\n  --username=s*                  PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "upload") { print "pause upload - Upload file(s)\n\nUsage:\n  pause upload --help (or -h, -?)\n  pause upload --version (or -v)\n  pause upload [options] <files> ...\n\nMain options:\n  --delay=s   Pause a number of seconds between files\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n  --subdir=s  Subdirectory to put the file(s) into [\"\"]\n\nConfiguration options:\n  --config-path=filename  Set path to configuration file\n  --config-profile=s      Set configuration profile to use\n  --no-config             Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s  Choose output format, e.g. json, text\n  --json      Set output format to json\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s*                  PAUSE password\n  --quiet                        Set logging level to error\n  --retries=i                    Number of retries when received 5xx HTTP error from server [2]\n  --retry-delay=s                How long to wait before retrying [3]\n  --trace                        Set logging level to trace\n  --username=s*                  PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } else { _pci_err([500, "Unknown subcommand2: $sc_name"]) } exit 0 },
  'json' => sub { $_pci_r->{format} = (-t STDOUT) ? "json-pretty" : "json"; },
  'log-level=s' => sub { if ($_[1] eq "trace") { Log::Any::Adapter->set("Screen", min_level=>"trace") } if ($_[1] eq "debug") { Log::Any::Adapter->set("Screen", min_level=>"debug") } if ($_[1] eq "info" ) { Log::Any::Adapter->set("Screen", min_level=>"info" ) } if ($_[1] eq "error") { Log::Any::Adapter->set("Screen", min_level=>"error") } if ($_[1] eq "fatal") { Log::Any::Adapter->set("Screen", min_level=>"fatal") } if ($_[1] eq "none")  { Log::Any::Adapter->set("Screen", min_level=>"none")  } $_pci_r->{log_level} = $_[1]; },
  'naked-res' => sub { $_pci_r->{naked_res} = 1; },
  'no-config' => sub { $_pci_r->{read_config} = 0; },
  'no-env' => sub { $_pci_r->{read_env} = 0; },
  'no-naked-res|nonaked-res' => sub { $_pci_r->{naked_res} = 0; },
  'quiet' => sub { Log::Any::Adapter->set("Screen", min_level=>"error"); $_pci_r->{log_level} = "error"; },
  'subcommands' => sub { print "Available subcommands:\n  cleanup\n  ls\n  ls-dists\n  ls-mods\n  reindex\n  rm\n  undelete\n  upload\n"; exit 0 },
  'trace' => sub { Log::Any::Adapter->set("Screen", min_level=>"trace"); $_pci_r->{log_level} = "trace"; },
  'verbose' => sub { Log::Any::Adapter->set("Screen", min_level=>"info"); $_pci_r->{log_level} = "info"; },
  'version|v' => sub { no warnings 'once'; require WWW::PAUSE::Simple; print "pause version ", $main::VERSION // '?', ($main::DATE ? " ($main::DATE)" : ''), "\n"; print "  Generated by Perinci::CmdLine::Inline version 0.48 (2017-01-16)\n"; exit 0 },
};
my $go_spec2 = {
  options => {
    'cmd=s' => {
      handler => sub { $_[2]{subcommand} = [$_[1]]; $_pci_r->{subcommand_name} = $_[1]; },
    },
    'config-path=s@' => {
      handler => sub {},
    },
    'config-profile=s' => {
      handler => sub {},
    },
    'debug' => {
      handler => sub {},
    },
    'format=s' => {
      handler => sub {},
    },
    'help|h|?' => {
      handler => sub {},
    },
    'json' => {
      handler => sub {},
    },
    'log-level=s' => {
      handler => sub {},
    },
    'naked-res' => {
      handler => sub {},
    },
    'no-config' => {
      handler => sub {},
    },
    'no-env' => {
      handler => sub {},
    },
    'no-naked-res|nonaked-res' => {
      handler => sub {},
    },
    'quiet' => {
      handler => sub {},
    },
    'subcommands' => {
      handler => sub {},
    },
    'trace' => {
      handler => sub {},
    },
    'verbose' => {
      handler => sub {},
    },
    'version|v' => {
      handler => sub {},
    },
  },
  subcommands => {
    'cleanup' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'n=i' => {
          handler => sub { $_pci_args{'num_keep'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'num-keep=i' => {
          handler => sub { $_pci_args{'num_keep'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'protect-file=s@' => {
          handler => sub { if ($mentioned_args{'protect_files'}++) { push @{ $_pci_args{'protect_files'} }, $_[1] } else { $_pci_args{'protect_files'} = [$_[1]] } },
        },
        'protect-files-json=s' => {
          handler => sub { $_pci_args{'protect_files'} = _pci_json()->decode($_[1]); },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'ls' => {
      options => {
        'del' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'no-del' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nodel' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'ls-dists' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'newest' => {
          handler => sub { $_pci_args{'newest'} = $_[1]; },
        },
        'newest-n=i' => {
          handler => sub { $_pci_args{'newest_n'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'no-newest' => {
          handler => sub { $_pci_args{'newest'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nonewest' => {
          handler => sub { $_pci_args{'newest'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'ls-mods' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'module=s@' => {
          handler => sub { if ($mentioned_args{'modules'}++) { push @{ $_pci_args{'modules'} }, $_[1] } else { $_pci_args{'modules'} = [$_[1]] } },
        },
        'modules-json=s' => {
          handler => sub { $_pci_args{'modules'} = _pci_json()->decode($_[1]); },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'type=s' => {
          handler => sub { $_pci_args{'type'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'reindex' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'rm' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'protect-file=s@' => {
          handler => sub { if ($mentioned_args{'protect_files'}++) { push @{ $_pci_args{'protect_files'} }, $_[1] } else { $_pci_args{'protect_files'} = [$_[1]] } },
        },
        'protect-files-json=s' => {
          handler => sub { $_pci_args{'protect_files'} = _pci_json()->decode($_[1]); },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'undelete' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'upload' => {
      options => {
        'delay=s' => {
          handler => sub { $_pci_args{'delay'} = $_[1]; },
        },
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=i' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'retry-delay=s' => {
          handler => sub { $_pci_args{'retry_delay'} = $_[1]; },
        },
        'subdir=s' => {
          handler => sub { $_pci_args{'subdir'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
  },
  default_subcommand => undef,
};
{
  local @ARGV = @ARGV;
  my $old_conf = Getopt::Long::EvenLess::Configure("pass_through");
  Getopt::Long::EvenLess::GetOptions(%$go_spec1);
  Getopt::Long::EvenLess::Configure($old_conf);
  { my $first_non_opt_arg; for (@ARGV) { next if /^-/; $first_non_opt_arg = $_; last } if (!length $_pci_r->{subcommand_name} && defined $first_non_opt_arg) { $_pci_r->{subcommand_name} = $first_non_opt_arg } }
}
{
  last unless $_pci_r->{read_env};
  my $env = $ENV{"PAUSE_OPT"};
  last unless defined $env;
  require Complete::Bash;
  my ($words, undef) = @{ Complete::Bash::parse_cmdline($env, 0) };
  unshift @ARGV, @$words;
}
if ($_pci_r->{read_config}) {
$log->tracef("Reading config file(s) ...");
  require Perinci::CmdLine::Util::Config;

  my $res = Perinci::CmdLine::Util::Config::read_config(
    config_paths     => $_pci_r->{config_paths},
    config_filename  => ["pause.conf"],
    config_dirs      => undef // ["$ENV{HOME}/.config", $ENV{HOME}, "/etc"],
    program_name     => "pause",
  );
  _pci_err($res) unless $res->[0] == 200;
  $_pci_r->{config} = $res->[2];
  $_pci_r->{read_config_files} = $res->[3]{"func.read_files"};
  $_pci_r->{_config_section_read_order} = $res->[3]{"func.section_read_order"}; # we currently dont want to publish this request key

  $res = Perinci::CmdLine::Util::Config::get_args_from_config(
    r                  => $_pci_r,
    config             => $_pci_r->{config},
    args               => \%_pci_args,
    program_name       => "pause",
    subcommand_name    => $_pci_r->{subcommand_name},
    config_profile     => $_pci_r->{config_profile},
    common_opts        => {},
    meta               => $_pci_metas->{ $_pci_r->{subcommand_name} },
    meta_is_normalized => 1,
  );
  die $res unless $res->[0] == 200;
  my $found = $res->[3]{"func.found"};
  if (defined($_pci_r->{config_profile}) && !$found && defined($_pci_r->{read_config_files}) && @{$_pci_r->{read_config_files}} && !$_pci_r->{ignore_missing_config_profile_section}) {
    _pci_err([412, "Profile '$_pci_r->{config_profile}' not found in configuration file"]);
  }
}
my $res = Getopt::Long::Subcommand::GetOptions(%$go_spec2);
_pci_err([500, "GetOptions failed"]) unless $res->{success};
if (!length $_pci_r->{subcommand_name}) { print $help_msg; exit 0 }
}

### check arguments

{
my $res = _pci_check_args(\%_pci_args);
_pci_err($res) if $res->[0] != 200;
$_pci_r->{args} = \%_pci_args;
}

### call function

{
$log->tracef("Calling function ...");
my $sc_name = $_pci_r->{subcommand_name};
if ($sc_name eq "cleanup") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::delete_old_releases(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "ls") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "ls-dists") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_dists(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "ls-mods") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_modules(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "reindex") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::reindex_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "rm") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::delete_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "undelete") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::undelete_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "upload") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::upload_files(%_pci_args) };
    if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}
}

### format & display result

{
$log->tracef("Displaying result ...");
my $fres;
my $save_res; if (exists $_pci_r->{res}[3]{"cmdline.result"}) { $save_res = $_pci_r->{res}[2]; $_pci_r->{res}[2] = $_pci_r->{res}[3]{"cmdline.result"} }
my $is_success = $_pci_r->{res}[0] =~ /\A2/ || $_pci_r->{res}[0] == 304;
my $is_stream = $_pci_r->{res}[3]{stream} // $_pci_meta_result_stream // 0;
if ($is_success && (0 || $_pci_meta_skip_format || $_pci_r->{res}[3]{"cmdline.skip_format"})) { $fres = $_pci_r->{res}[2] }
elsif ($is_success && $is_stream) {}
else { require Perinci::Result::Format::Lite; $is_stream=0; $fres = Perinci::Result::Format::Lite::format($_pci_r->{res}, ($_pci_r->{format} // $_pci_r->{res}[3]{"cmdline.default_format"} // "text"), $_pci_r->{naked_res}, 0) }

my $use_utf8 = $_pci_r->{res}[3]{"x.hint.result_binary"} ? 0 : 0;
if ($use_utf8) { binmode STDOUT, ":utf8" }
if ($is_stream) {
    my $code = $_pci_r->{res}[2]; if (ref($code) ne "CODE") { die "Result is a stream but no coderef provided" } if ($_pci_meta_result_type_is_simple) { while(defined(my $l=$code->())) { print $l; print "\n" unless $_pci_meta_result_type eq "buf"; } } else { while (defined(my $rec=$code->())) { print _pci_json()->encode($rec),"\n" } }
} else {
    print $fres;
}
if (defined $save_res) { $_pci_r->{res}[2] = $save_res }
}

### exit

{
my $status = $_pci_r->{res}[0];
my $exit_code = $_pci_r->{res}[3]{"cmdline.exit_code"} // ($status =~ /200|304/ ? 0 : ($status-300));
exit($exit_code);
}

# BEGIN Local::_pci_check_args
sub _pci_check_args {
    my ($args) = @_;
    my $sc_name = $_pci_r->{subcommand_name};
    if ($sc_name eq "cleanup") {
      FILL_FROM_POS: {
            1;
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"num_keep"} //= 1;
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: num_keep"] if exists($args->{"num_keep"}) && !defined($args->{"num_keep"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: protect_files"] if exists($args->{"protect_files"}) && !defined($args->{"protect_files"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "ls") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "ls-dists") {
      FILL_FROM_POS: {
            1;
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: newest_n"] if exists($args->{"newest_n"}) && !defined($args->{"newest_n"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "ls-mods") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"modules"}) { return [400, "You specified --module but also argument #0"]; } else { $args->{"modules"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required value for argument: modules"] if exists($args->{"modules"}) && !defined($args->{"modules"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required value for argument: type"] if exists($args->{"type"}) && !defined($args->{"type"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "reindex") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "rm") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: protect_files"] if exists($args->{"protect_files"}) && !defined($args->{"protect_files"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "undelete") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "upload") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        $args->{"retries"} //= 2;
        $args->{"retry_delay"} //= 3;
        $args->{"subdir"} //= "";

        # check required args
        return [400, "Missing required value for argument: delay"] if exists($args->{"delay"}) && !defined($args->{"delay"});
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required argument: password"] unless exists $args->{"password"};
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: retry_delay"] if exists($args->{"retry_delay"}) && !defined($args->{"retry_delay"});
        return [400, "Missing required value for argument: subdir"] if exists($args->{"subdir"}) && !defined($args->{"subdir"});
        return [400, "Missing required argument: username"] unless exists $args->{"username"};
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    } else { _pci_err([500, "Unknown subcommand1: $sc_name"]); }
}
1;

# END Local::_pci_check_args



=head1 SYNOPSIS

First create a config file C<~/pause.conf> containing:

 username=<Your PAUSE ID>
 password=<Your PAUSE password>

or if you have C<~/.pause> from L<cpan-upload>, C<pause> can read it too
(encrypted C<.pause> is currently not supported).

Then:

 # upload one or more files
 % pause upload Foo-Bar-0.12.tar.gz Baz-2.24.tar.gz
 % pause upload Foo-Bar-0.12.tar.gz --subdir old/2014; # upload to a subdir

 # list your files
 % pause ls
 % pause ls 'App-*'; # accept filenames/wildcard patterns, note: quote first
 % pause ls -l     ; # see file sizes/mtimes/etc instead of just names

 # list your dists
 % pause ls-dists

 # delete files
 % pause rm Foo-Bar-0.12.tar.gz Foo-Bar-0.12.readme Foo-Bar-0.12.meta
 % pause rm 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # undelete files scheduled for deletion (but not actually deleted yet)
 % pause undelete Foo-Bar-0.12.tar.gz Foo-Bar-0.12.readme Foo-Bar-0.12.meta
 % pause undelete 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # force reindexing
 % pause reindex Foo-Bar-0.12.tar.gz Foo-Bar-0.12.meta
 % pause reindex 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # clean old releases, by default will only leave the newest non-dev version
 % pause cleanup
 % pause cleanup -n 3 ; # keep 3 versions (newest + previous two)

To view permissions:

 # list all modules that you have permissions of
 % pause ls-mods
 % pause ls-mods -l ; # show detail

 # list all modules matching a wildcard
 % pause ls-mods -l 'Unix*'

 # list all modules you have co-maint of
 % pause ls-mods -l --type co-maint

To change permissions (not yet implemented):

 ...

To change your password (not yet implemented):

 ...

To view your account info (not yet implemented):

 ...

To change your email forwarding (not yet implemented):

 ...


=head1 append:FILES

F<~/.pause>

=cut
